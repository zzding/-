# 有了指针为什么还要有引用
Matrix operator (Matrix * lhs, Matrix * rhs);

这样以来乘法就会写成下面这样：

Matrix a,b,c; a = &b * &c;

上面这样一写的话，看起来就很丑了，没人会接受，太麻烦，重载的目标就是简洁优雅

引用自带非空，不可修改属性



# 如何禁止程序自动生成拷贝构造函数
我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。
```cpp
class B {
public:
	B(){}
private:
	B(B&) {}
};
class C : public B {

public:
	void func() {
		C c;
		C b = c;
	}
};
```

# cast
reinterpret_cast   底层强制转换，不能是自定义类型，只能时指针等类型，可以是POD
const_cast一般用于修改底指针。如const char *p形式   如果最终指向的那个是const的话，则不会改变最终的，只会改变const_cast返回的
dynamic_cast有类型检查，基类向派生类转换比较安全
，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断


static_cast 用于进行比较“自然”和低风险的转换不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。


# 为什么模板类一般都是放在一个h文件中
两个过程 编译 和链接，只引用头文件是看不见cpp文件，一般情况下，编译器找不到某个函数的实现会寄希望于链接器， 而模板需要两次编译，在实现是编译，在用到的地方编译，否则不完整
这时，cpp编译不完整，连接器无法链接，
