# 1、编译器如何处理系统调用
> 有一个特殊的RISC-V指令，程序可以调用这个指令，并将控制权交给内核。所以，
实际上当你运行C语言并执行例如open或者write的系统调用时，从技术上来说，open
是一个C函数，但是这个函数内的指令实际上是机器指令，也就是说我们调用的open函
数并不是一个C语言函数，它是由汇编语言实现，组成这个系统调用的汇编语言实际上
在RISC-V中被称为ecall。这个特殊的指令将控制权转给内核。之后内核检查进程的
内存和寄存器，并确定相应的参数

# 2、父进程与子进程的关系
>使用fork函数得到的子进程是父进程的处继承了整个进程的地址空间，包括：**「进
程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、
进程组号、当前工作目录、根目录、资源限制、控制终端」**

### 写时复制
在 Linux 系统中，调用 fork 系统调用创建子进程时，并不会把父进程所有占用的内存页复
制一份，而是与父进程共用相同的内存页，而当子进程或者父进程对内存页进行修改时才会进
行复制
- 创建子进程时，将父进程的 虚拟内存 与 物理内存 映射关系复制到子进程中，并将内存设置为只读（设置为只读是为了当对内存进行写操作时触发 缺页异常）当子进程对 虚拟内存页M 进行写操作，便会触发 缺页异常（因为已经将 虚拟内存页M 设置为只读）。在缺页异常处理函数中，对 物理内存页G 进行复制一份新的 物理内存页G’，并且将子进程的 虚拟内存页M 映射到 物理内存页G’，同时将父子进程的 虚拟内存页M 设置为可读写。
- 当子进程或者父进程对内存数据进行修改时，便会触发 写时复制 机制：将原来的内存页复制一份新的，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写。
![](https://img-blog.csdnimg.cn/8e98b81fe07740d889655fb943e49850.png)
### 调用exec函数
1. fork函数用于创建一个子进程，该子进程几乎拷贝了父进程的全部内容。
2. exec函数族提供了一种在进程中启动另一个程序执行的方法。它可以根据指定的文件名或
目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段。在执行完之
后，原调用进程的内容除了进程号外，其他全部都被替换了。
3. 可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。
4. exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述
符，例如0，1，2等。它们在新的程序中表示相同的东西。
5. 通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程
不复存在了，所以exec系统调用已经没有地方能返回了。只有在运行出错时才会返回
> 每当进程调用一种exec函数时，该进程完全由新程序代换，而新程序从main函数开始执
行。Exec并不创建新进程，所以前后进程ID也不会变。Exec只是用另一个新程序替换了当前
进程的正文、数据、堆和栈段。

# 3、wait函数
父进程等待子进程退出，**<font color="red">注意，wait只会等待一个子进程退出，多个子进程中无法分辨是哪个子进程退出了，因此，要等待多个子进程退出，必须调用多个wait**</font>
但是wait返回值是子进程号，wait返回后可以知道是哪个进程退出了