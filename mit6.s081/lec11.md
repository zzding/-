# 1、进程切换过程
从旧进程的用户-内核转换（系统调用或中断）到内核线程，
从当前CPU的调度线程进行上下文切换，从新进程的内核线程进行上下文切换，然后从陷阱返回到用户级进程。
# 2、多CPU调度
v6调度程序每个CPU都有一个专用的线程（保存的寄存器和堆栈），因为在旧进程的内核栈上执行调度程序是不安全的：
其他核心可能唤醒该进程并运行它，在两个不同的核心上使用相同的堆栈将导致灾难。

# 3、调用过程
usertrap -------> yield ----------> sched ----------> swtch将当前的上下文保存在p->context中，并切换到之前保存在cpu->scheduler中的调度程序上下文

# 4、调度过程
- 调度器以每个CPU一个特殊的线程的形式存在，每个线程都运行调度器函数。
- 该函数负责选择下一个要运行的进程。
- 一个想要让出CPU的进程必须获取自己的进程锁p->lock，释放任何其他正在持有的锁，更新自己的状态（p->state），然后调用sched函数。
**由于持有了锁，中断应该被禁用。**
- 最后，sched函数调用swtch函数将当前上下文保存在p->context中，并切换到cpu->scheduler的调度器上下文中。
- swtch函数在调度器的堆栈上返回，就好像调度器的swtch函数返回一样。
- 调度器继续进行for循环，找到要运行的进程，切换到它，并且循环重复。

- 内核线程总是在sched函数中放弃CPU，并且总是切换到调度器中的相同位置，调度器（几乎）总是切换到之前调用sched的某个内核线程。