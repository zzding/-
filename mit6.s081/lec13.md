# 1、XV6中，不允许进程在执行switch函数的过程中，持有任何其他的锁
要切换出的线程持有其他的锁，切换进的线程要使用这个锁，但是会导致这个线程一直在等待。导致死锁。  
导致死锁是因为：切换过程都发生在内核中，acquire函数在等待锁之前会关闭中断，否则的话可能会引起死锁  
你或许会想，为什么不能先“自旋”等待锁释放，再关闭中断？
**因为这样会有一个短暂的时间段锁被持有了但是中断没有关闭，在这个时间段内的设备的中断处理程序可能会引起死锁。**

# 2、p->kill
p->kill 需要在能安全停止运行的位置时，会检查自己的killed标志位，如果设置为1，目标进程会自愿的执行exit系统调用。  
```c
if(p->killed)
    exit(-1);
```
类似的，在usertrap函数的最后，也有类似的代码。在执行完系统调用之后，进程会再次检查自己是否已经被kill了。  
即使进程是被中断打断，这里的检查也会被执行。例如当一个定时器中断打断了进程的运行，我们可以通过检查发现进程是killed状态，之后进程会调用exit退出。  