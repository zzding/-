# 1、I/O 并发
需要注意的一个常见模式是通过缓冲和中断将设备活动与进程活动解耦。即使没有进程等待读取输入，控制台驱动程序仍可以处理输入；后续的读取操作将看到输入。
类似地，进程可以发送输出而无需等待设备。
这种解耦可以通过允许进程与设备I/O并发执行来提高性能，尤其在设备较慢（如UART）或需要即时响应（如回显键入的字符）时非常重要。这个思想有时被称为I/O并发。

# 2、定时器中断
RISC-V要求定时器中断在机器模式下进行处理，而不是在监管者模式下。
RISC-V机器模式在没有分页的情况下执行，并具有一组单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码并不实际。因此，xv6完全独立于上面介绍的陷阱机制来处理定时器中断。  

定时器中断可以发生在执行用户或内核代码的任何时刻；内核无法在关键操作期间禁用定时器中断。因此，定时器中断处理程序必须以一种不会干扰被中断的内核代码的方式完成其工作。**基本策略是让处理程序要求 RISC-V 发起一个“软件中断”并立即返回。**RISC-V通过普通的陷阱机制将软件中断传递给内核，并允许内核禁用它们。处理由定时器中断生成的软件中断

# 3、PLIC
## 3.1、PLIC流程
- PLIC会通知当前有一个待处理的中断
- 其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理
- CPU核处理完中断之后，CPU会通知PLIC
- PLIC将不再保存中断的信息

## 3.2 PLIC有没有什么机制能确保中断一定被处理？
> 这里取决于内核以什么样的方式来对PLIC进行编程。PLIC只是分发中断，而内核需要对PLIC进行编程来告诉它中断应该分发到哪。  
> 实际上，内核可以对中断优先级进行编程，这里非常的灵活。

# 4、设备驱动
通常来说，管理设备的代码称为驱动，所有的驱动都在内核中。如果我们查看代码的结构，我们可以发现大部分驱动都分为两个部分，bottom/top。
- bottom部分通常是Interrupt handler。当一个中断送到了CPU，并且CPU设置接收这个中断，CPU会调用相应的Interrupt handler。Interrupt handler并不运行在任何特定进程的context中，它只是处理中断。
- top部分，是用户进程，或者内核的其他部分调用的接口。对于UART来说，这里有read/write接口，这些接口可以被更高层级的代码调用。

# 5、SIE SPI
## SIE
SIE寄存器：该寄存器用于在特权级别为Supervisor（内核）时启用或禁用中断。
当在SIE寄存器中启用中断时，当相应的中断事件发生时，处理器将生成中断异常。通过设置或清除SIE寄存器中的特定位，可以启用或禁用特定的中断。
## SPI
SIP寄存器：该寄存器表示在特权级别为Supervisor时待处理的中断请求。
SIP寄存器的每个位表示一个特定的中断源，如果该位被设置（1），则表示该特定中断的中断请求待处理。操作系统/内核可以检查SIP寄存器以确定哪些中断需要被处理。  
> SIE和SIP寄存器对于管理RISC-V处理器中的中断和异常非常重要。  
> 操作系统/内核通常使用这些寄存器来控制中断处理并根据其重要性对中断请求进行优先级排序。SIE寄存器用于启用或禁用中断，而SIP寄存器指示需要由内核处理的待处理中断请求。
