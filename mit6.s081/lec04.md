# 1、trampoline page跳板页

"trampoline page"（跳板页）是指在不同的地址空间中将同一块物理内存页映射到多个虚拟地址空间的技术。这在操作系统中经常被用于实现共享代码或数据的机制。

通过使用跳板页，多个进程可以共享同一块物理内存，而不需要为每个进程复制一份相同的内容。当进程访问该共享内存时，页表将其虚拟地址映射到同一块物理内存，从而实现共享。

跳板页的一个常见用途是在多个用户进程之间共享库代码。多个进程可以将相同的库代码映射到各自的地址空间，以便它们可以共享这些代码，节省内存空间并提高系统性能。

# 2、虚拟内存表示
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Invalid (25 bits)    | Index (27 bits)           | Offset (12 bits) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

被组织成2^27项的页表，每页4K(2^12)，
物理地址位56位，前44位为PPN 记录在page table中，后12为为offset

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  PPN (44 bits)      |    Offset (12 bits)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

![](/%E7%AC%94%E8%AE%B0/mit6.s081/picture/map.jpg)

![](/%E7%AC%94%E8%AE%B0/mit6.s081/picture/a.png)
将根页表页的物理地址写入寄存器satp;

# 3、三级分页
如果用于地址转换的任何一个PTE不存在，分页硬件会引发页错误异常，由内核来处理该异常（请参阅第4章）。这种三级结构允许页表在常见情况下省略整个页表页，即大范围的虚拟地址没有映射。

每个PTE包含标志位，告诉分页硬件如何使用关联的虚拟地址。PTE_V指示PTE是否存在：如果未设置，对该页的引用会引发异常（即不允许）。PTE_R控制是否允许指令读取该页。PTE_W控制是否允许指令写入该页。PTE_X控制CPU是否可以将页的内容解释为指令并执行它们。PTE_U控制是否允许用户模式的指令访问该页；如果未设置PTE_U，则该PTE只能在监管者模式下使用。图3.2展示了所有这些的工作方式。标志位和其他与页相关的硬件结构在(kernel/riscv.h)中定义。


# 4、xv6目前只支持100MB内存

![](/%E7%AC%94%E8%AE%B0/mit6.s081/picture/%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84.png)


# 5、映射
xv6的kernel是直接映射到物理内存上的，而物理内存会被映射两次，一次是直接映射，一次在虚拟空间顶部


# 6、内核栈与用户进程栈区别
6.1 用途和权限：

- 内核栈（Kernel Stack）：内核栈用于保存操作系统内核执行过程中的临时数据和函数调用信息，包括中断处理、异常处理、系统调用等。
内核栈属于内核空间，只能由内核代码访问，用户进程无法直接访问或修改内核栈的内容。
- 用户进程的栈（User Stack）：用户进程的栈用于保存用户程序执行过程中的函数调用信息、局部变量和参数等。它属于用户空间，用户进
程可以直接操作和管理自己的栈。
6.2 内存空间：

- 内核栈：内核栈是为每个运行的进程在内核空间分配的一段内存区域。每个进程都有自己的内核栈，用于保存进程在内核态执行时的上下文信息。
- 用户进程的栈：用户进程的栈位于用户空间，是进程在用户态执行时使用的栈，用于保存函数调用信息和局部变量。用户进程的栈是通过内存管理机制进行分配和管理的。
6.3 大小和管理：

- 内核栈：内核栈的大小是固定的，由操作系统在进程创建时进行分配。内核栈的大小通常比用户进程的栈要大，因为内核执行过程中需要保存更多的上下文信息。
- 用户进程的栈：用户进程的栈大小可以根据需要动态调整，当进程执行函数调用或分配局部变量时，栈会动态增长。用户进程的栈由操作系统在进程创建时分配，并由进程自身负责管理。


虽然内核通过高内存映射来使用其栈，但内核也可以通过直接映射的地址访问这些栈。另一种设计可能只使用直接映射，并在直接映射的地址上
使用栈。然而，在这种安排下，提供保护页面将涉及取消映射原本指向物理内存的虚拟地址，这将使其难以使用。

内核使用PTE_R和PTE_X权限来映射跳板页和内核代码页。内核从这些页面中读取和执行指令。内核使用PTE_R和PTE_W权限来映射其他页面，以
便可以对这些页面中的内存进行读写。保护页面的映射是无效的，即PTE_V未设置。



# 7、ELF格式
全称Executable and Linkable Format  可执行和可链接格式  
ELF格式是一种常用的文件格式，用于描述可执行文件、目标代码、共享库和核心转储文件。

ELF格式提供了一种标准化的方式来组织和表示可执行文件的各个组成部分，包括代码、数据、符号和重定位信息。它使得操作系统能够通过理解ELF文件的结构和布局来加载和执行应用程序。

LF文件由多个部分组成，每个部分都有特定的功能。其中常见的部分包括：

- ELF头部：包含关于ELF文件的基本信息，如目标体系结构、入口点地址以及其他部分的位置和大小。

- 程序头表：描述了需要加载到内存中供执行的可执行文件的段。表中的每个条目指定了段的类型（如代码段、数据段、动态链接信息）、虚拟地址和大小。

- 节头表：包含了对每个节的描述信息。节可以包含代码、数据、符号、重定位信息等内容。节头表提供了关于每个节的布局和特性的信息。

- 代码段：通常包含应用程序的可执行代码。

- 数据段：存储应用程序使用的初始化数据。

- 符号表：包含了应用程序定义和引用的符号信息。符号代表变量、函数和其他程序实体。

- 重定位表：包含了在运行时动态链接器进行地址调整和解析符号引用所需的信息。



# 8、

在内核中，通过"直接映射"的方式访问RAM和内存映射设备寄存器，即将资源映射到虚拟地址与物理地址相等的位置。例如，内核本身位于虚拟
地址空间和物理内存中的KERNBASE=0x80000000处。直接映射简化了读取或写入物理内存的内核代码。例如，当fork为子进程分配用户内存
时，分配器返回该内存的物理地址；fork在将父进程的用户内存复制到子进程时，直接将该地址用作虚拟地址。

但也有一些内核虚拟地址不是直接映射的：

跳板页（trampoline page）：它映射在虚拟地址空间的顶部；用户页表也具有相同的映射。第4章讨论了跳板页的作用，但这里我们可以看到
页面表的一个有趣用例：内核的虚拟地址空间中的物理页（包含跳板代码）被映射两次：一次在虚拟地址空间的顶部，一次进行直接映射。
内核栈页（kernel stack pages）：每个进程都有自己的内核栈，它被映射在较高的位置，以便在其下方留出未映射的守护页。守护页的PTE
是无效的（即，PTE_V未设置），这样如果内核栈溢出，它很可能引发异常并导致内核崩溃。没有守护页，溢出的栈会覆盖其他内核内存，导致操作错误。崩溃的异常是更可取的行为。









# S、一些问题

> - xv6的设计选择了简化的结构，将所有的指令和数据都放在同一个程序段中。这意味着指令和数据在内存中是连续存放
的，不需要区分不同的段。 

> - xv6 中，内核空间从 KERNBASE（0x80000000）开始; 用户空间通常位于低地址部分，例如在 xv6 中，用户空间从 0 开始。

> - 在 xv6 中，当切换进程时，内核空间和用户空间的映射会发生变化。  
切换进程的操作：
1. 保存当前进程的上下文：当前进程的寄存器值、页表等相关信息会被保存。

2. 加载新进程的页表：新进程的页表会被加载到处理器的页表寄存器中，使其成为当前的活动页表。即需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单,TLB(Translation Lookside Buffer 快表)也会被清空

3. 更新地址空间映射：通过页表的映射关系，将新进程的虚拟地址映射到相应的物理地址。

4. 恢复新进程的上下文：新进程的上下文，包括寄存器值、页表等信息会被恢复，使新进程可以继续执行。

> - 在RISC-V中，物理内存地址是56bit。  
> - 物理内存地址是56bit，其中44bit是物理page号（PPN，Physical Page Number），剩下12bit是offset完全继承自虚拟内存地址

  
  
> 主板的设计人员决定了，在完成了虚拟到物理地址的翻译之后，如果得到的物理地址大于0x80000000会走向DRAM芯片，如果得到的物理地址
低于0x80000000会走向不同的I/O设备。这是由这个主板的设计人员决定的物理结构。如果你想要查看这里的物理结构，你可以阅读主板的手
册，手册中会一一介绍物理地址对应关系。
