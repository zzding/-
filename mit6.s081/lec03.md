<font color="red"></font>
<font color="yellow"></font>
# 1、RISC-V 三种模式
CPU 为强隔离提供硬件支持。 例如RISC-V有三种CPU可以执行指令的模式：机器模式、管理模式和用户模式。 在机
器模式下执行的指令具有完全特权； CPU 以机器模式启动。 机器模式主要用于配置计算机<font color="yellow">？？配置计算机的哪方面，为什么配置需要机器模式？？</font>。 xv6在机器模式下执行
几行，然后切换到管理员模式。在管理员模式下，CPU可以执行特权指令：例如，启用和禁用中断，读取和写入保存页
表地址的寄存器等 . 如果处于用户模式的应用程序试图执行特权指令，则 CPU 不会执行该指令，而是切换到管理员
模式，以便管理员模式代码可以终止应用程序。

运行在内核空间（或管理员模式）的软件称为内核。

CPU 提供了一条特殊的指令，可以将 CPU 从用户模式切换到管理员模式，并在内核指定的入口点进入内核
（RISC-V 为此提供了 ecall 指令。）

一旦 CPU 切换到管理模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝它 或执行它。 内核控制转换到管理模式的入口点很重要； 例如，如果应用程序可以决定内核入口点，则恶意应用程序可以在跳过参数验证的位置进入内核。

# 2、宏内核与微内核
**宏内核**：整个操作系统驻留在内核中，因此所有系统调用的实现都运行在管理模式下。 整个操作系统以完全的硬件权限运行 
优点：  
- 设计简单，操作系统设计者不必决定操作系统的哪一部分不需要完整的硬件特权。
- 操作系统的不同部分更容易协作。如：操作系统可能有一个缓冲区缓存，可以由文件系统和虚拟内存系统共享。（直接在内核空间中开辟缓存）  
缺点：  
- 操作系统不同部分之间的接口通常很复杂，内核开发人员容易犯错，而单内核中发生错误导致整个系统崩溃  

**微内核**：操作系统设计人员可以最大限度地减少在管理员模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。
缺点：  
- 微内核比宏内核更频繁切换用户态和内核态，导致性能更差。
- 在微内核中，每个部分之间都很好的隔离开了，各部分的数据共享更困难。


# 3、区分普通指令还是特权指令(privileged instruction)
在处理器里面有一个flag,当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果
指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令。ps(BIOS是一段计算机自带的代码，它会先启动，之后它会启动操作系统).

# 4、在用户态尝试执行特权指令
用户程序会通过系统调用来切换到kernel mode。当用户程序执行系统调用，会通过ECALL触发一个软中断
（software interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程
序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的特殊权限
指令。ECALL接收一个数字参数，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。不论
是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用
ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。之后控制权到了syscall函
数，syscall会实际调用相应系统调用。

# 5、内核态对系统调用的核查与控制
在内核侧实现fork的位置可以实现任何的检查，例如检查系统调用的参数，并决定应用程序是否被允许执行系统调用
内核会通过硬件设置一个定时器，定时器到期之后会将控制权限从用户空间转移到内核空间，之后内核就有了控制能
力并可以重新调度CPU到另一个进程中

# 6、mkfs 作用
它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。

# 7、xv6启动
1. 当 RISC-V 计算机开机时，它会自行初始化并运行存储在只读存储器中的引导加载程序。 引导加载程序将 xv6
 内核加载到内存中。 然后，在机器模式下，CPU 从 _entry (kernel/entry.S:6) 开始执行 xv6。 RISC-V 在
 禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。  
2. 加载程序将 xv6 内核加载到物理地址 0x80000000 的内存中。(0x0:0x80000000 包含 I/O 设备。)
3. 设置好堆栈，_entry 在开始时调用 C 代码 (kernel/start.c:21)。
4. 函数 start 执行一些只允许在机器模式下进行的配置，然后切换到管理员模式(指令mret)。
5. 在进入管理员模式之前，start 还执行一项任务：它对时钟芯片进行编程以生成定时器中断。 完成这些内务处理
后，通过调用 mret 开始“返回”到主管模式。 这会导致程序计数器更改为 main(kernel/main.c:11)。
6. main (kernel/main.c:11) 初始化多个设备和子系统后，它通过调用 userinit (kernel/proc.c:212) 创建
第一个进程。 第一个进程执行一个用 RISC-V 汇编编写的小程序 initcode.S (user/initcode.S:1)，它通过调
用 exec 系统调用重新进入内核。 正如我们在第 1 章中看到的，exec 将当前进程的内存和寄存器替换为一个新程
序（在本例中为 /init）。 一旦内核完成exec，它就会在/init进程中返回到用户空间。
7.




# 8、qemu工作流程
- 读取4字节或者8字节的RISC-V指令。
- 解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。
- 之后，在软件中执行相应的指令。
