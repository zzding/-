

![](../%E5%9B%BE/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png)

C[1] = A[1];  
C[2] = A[1] + A[2];  
C[3] = A[3];  
C[4] = A[1] + A[2] + A[3] + A[4];  
C[5] = A[5];  
C[6] = A[5] + A[6];  
C[7] = A[7];  
C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];   



$C[i] = A[i - 2^k+1] + A[i - 2^k+2] + ... + A[i]$;   //k为i的二进制中从最低位到高位连续零的长度


# 1、lowbit
```cpp
//某一位数最低一位1及后面所有0组成的二进制数
//lowbit(1110011000)  == 8
int lowbit(int x){
    return x & (-x);
}
```
将 x 的二进制所有位全部取反，再加 1，就可以得到 -x 的二进制编码。例如，6 的二进制编码是 110，全部取反后得到 001，加 1 得到 010。  

设原先 x 的二进制编码是 (...)10...00，全部取反后得到 [...]01...11，加 1 后得到 [...]10...00，也就是 -x 的二进制编码了。这里 x 二进制表示中第一个 1 是 x 最低位的 1。  

(...) 和 [...] 中省略号的每一位分别相反，所以 x & -x = (...)10...00 & [...]10...00 = 10...00，得到的结果就是 lowbit。


# 2、getsum
```cpp
int getsum(int x){
    int res = 0;
    while(x > 0){
        res += c[x];
        x = x - lowbit(x);
    }
}
```
计算$a[1] + a[2] + ... + a[x]$的总和  
根据管辖区间不断向左跳计算区间和

# 3、addnum
```cpp
void addnum(int pos, int num){
    while(pos <= n){
        c[pos] += num;
        pos = pos + lowbit(pos);
    }
}
```
树状数组是x 向 x + lowbit(x) 连边得到的图